
use heap
use flow
use string


# LR Parser Demo

# rule structure
# 
# +0 -> Next  :: Rule
# +1 -> State :: String
# +2 -> Read  :: Nullable<Char>
# +3 -> Goto  :: Nullable<String>

constant Rule::Next  be 0
constant Rule::State be 1
constant Rule::Read  be 2
constant Rule::Goto  be 3
constant Rule        be 4



# (State::String, Read, Goto)
let base-rule be 0
label init-table-entry
    call stack::swap
    pull goto
    call stack::swap
    pull read
    call stack::swap
    pull state

    push Rule
    call heap::allocate
    pull rule

    push rule
        write base-rule into rule at Rule::Next
        write state     into rule at Rule::State
        write read      into rule at Rule::Read
        write goto      into rule at Rule::Goto
    pull rule    

    let base-rule be rule
    return

label init-table
    string "s0"   into state-zero
    string "s1"   into state-one
    string "s2"   into state-two
    string "accept" into state-accept
    string "reject" into state-reject

    #core states
    push state-zero
    push 49
    push state-one
    call init-table-entry

    push state-one
    push 48
    push state-two
    call init-table-entry

    push state-one
    push 49
    push state-zero
    call init-table-entry

    push state-two
    push 48
    push state-one
    call init-table-entry

    #exits
    push state-zero
    push 0
    push state-accept
    call init-table-entry

    push state-one
    push 0
    push state-reject
    call init-table-entry

    push state-two
    push 0
    push state-reject
    call init-table-entry

    return


let source beknown
let state  beknown

label update
    push state
    call string::print
    output newline

    let iterator be base-rule
    read char from source
    let source be source plus 1

label update::loop
    if iterator equal 0 goto flow::return

    read next-rule    from iterator at Rule::Next
    read ref-state    from iterator at Rule::State
    read ref-char     from iterator at Rule::Read
    read next-state   from iterator at Rule::Goto

    #update state walker
    let iterator be next-rule

    #check state
    if ref-state unequal state goto update::loop
    if ref-char  unequal char  goto update::loop

    #state match
    let state be next-state

    return

    

label run
    let state be state-zero

label run::loop 
    call update

    if state equal state-reject goto flow::return
    if state equal state-accept goto flow::return
    goto run::loop





label main    
    call init-table
    string "10101" into source

    call run

    push state
    call string::print
    output newline
    






