#disclaimer: written while high

use heap
use math

# node structure
# 
# p+0 -> Type::Int
#   0 -> Invalid
#   1 -> Leaf
#   2 -> Add
#   3 -> Sub
#   4 -> Mul,
# 
# p+1 -> Content::Int
# p+2 -> Left ::Node
# p+3 -> Right::Node



let parse::expr be 0
label parse::next
    let parse::expr be parse::expr plus 1
    return
label parse::peek
    read parse::char from parse::expr
    return
label parse::pop
    call parse::peek
    call parse::next
    return




let type    be 0
let content be 0
let lhs     be 0
let rhs     be 0

label parse::object
    push 4 
    call heap::allocate
    call stack::dup
    pull ptr
    call stack::swap

    write type into ptr
    let ptr be ptr plus 1
    write content into ptr
    let ptr be ptr plus 1
    write lhs into ptr
    let ptr be ptr plus 1
    write rhs into ptr

    return




label parse::expr-stage-one
    #setup call to term
    push 2  
    call stack::swap
    return

label parse::expr-stage-two::done
    call stack::swap

    #step op char
    call parse::next

    #setup call to expression
    push 1
    call stack::swap
    return

label parse::expr-stage-two::plus
    push 2
    goto parse::expr-stage-two::done
label parse::expr-stage-two::minus
    push 3
    goto parse::expr-stage-two::done
label parse::expr-stage-two::times
    push 4
    goto parse::expr-stage-two::done

label parse::expr-stage-two
    call parse::peek
    if parse::char equal 43 goto parse::expr-stage-two::plus
    if parse::char equal 45 goto parse::expr-stage-two::minus
    if parse::char equal 42 goto parse::expr-stage-two::times

    #enable fall-through
    let routine be 0
    return

label parse::expr-stage-thr
    call stack::swap
    pull rhs
    call stack::swap
    pull type
    call stack::swap
    pull lhs

    goto parse::object


label parse::term-stage-two
    let routine be 0

    #pop closing bracket
    call parse::pop

    return

label parse::term-stage-one::continue
    #setup call to expression
    push 1
    call stack::swap
    return

label parse::term-stage-one
    call parse::pop 

    if parse::char equal 40 goto parse::term-stage-one::continue

    #enable fall-through
    let routine be 0

    #leaf
    let type be 1
    let content be parse::char minus 48

    goto parse::object



#mutual recursion helper
#(Routine::Int) => (::Node)
# 1 -> Expression
# 2 -> Term
label parse::rec
    call stack::swap
    #routine is set to zero as fall-through
    pull routine

    if routine equal 1 call parse::expr-stage-one
    if routine equal 2 call parse::term-stage-one

    push routine
    call stack::swap
        if routine unequal 0 call parse::rec
    call stack::swap
    pull routine

    if routine equal 1 call parse::expr-stage-two
    if routine equal 2 call parse::term-stage-two

    push routine
    call stack::swap
        if routine unequal 0 call parse::rec
    call stack::swap
    pull routine

    if routine equal 1 call parse::expr-stage-thr

    call stack::swap
    return



    
#(Expr::String) => (::Node)
label parse
    call stack::swap
    pull parse::expr

    #call to expr
    push 1
    call parse::rec

    call stack::swap
    return






let res be 0
label eval::done
    push res
    call stack::swap
    return

let node be 0
label eval::leaf
    let node be node plus 1
    read res from node
    goto eval::done

let res-right be 0
let res-left  be 0
label eval::add
    let res be res-left plus res-right
    goto eval::done
label eval::sub
    let res be res-left minus res-right
    goto eval::done
label eval::mul
    push res-left
    push res-right
    call math::mul
    pull res
    goto eval::done




#(Root::Node) => (Res::Int)
label eval
    call stack::swap
    pull node

    read type from node
    if type equal 1 goto eval::leaf
    push type
    
        let node be node plus 2
        read node-left from node
        let node be node plus 1
        read node-right from node

        push node-left
        push node-right

        call eval
        call stack::swap
        call eval

        pull res-left
        pull res-right

    pull type
    if type equal 2 goto eval::add
    if type equal 3 goto eval::sub
    if type equal 4 goto eval::mul

    #invalid defaults to zero
    push 0
    call stack::swap
    return





label main
    #string "((1+2)*4)-2" into expr
    string "(8-3)*(2+5)" into expr

    push expr
    call parse
    pull root

    push root
    call eval
    pull res

    print res








